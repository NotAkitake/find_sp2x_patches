## Creating Signature Files

Signature files are JSON files that define instructions on how to find patches for inside game DLLs.
We will not explain how to find signatures as it's a very technical and game-specific process.
However we will explain how signature files are created and formatted:

## File Naming

Name your file `<gamecode>-signatures.json`, where `<gamecode>` is the game's unique identifier (KFC, LDJ, etc.).

## Structure

Each file should start with a header object followed by an array of patch objects.

### Header Object

   - `gameCode`: The game's unique identifier (KFC, LDJ, etc.).
   - `dllName`: The name of the DLL file the patches are meant for.
   - `lastUpdated`: The date when the signature file was last updated.
   - `source`: The source URL or reference.

###### Example header

```json
{
   "gameCode": "KFC",
   "dllName": "soundvoltex.dll",
   "lastUpdated": "2024-10-27",
   "source": "https://sp2x.two-torial.xyz/"
},
```

### Patch Objects

   - `type`: The type of patch (e.g. `memory`, `union`, `number`, `hardcoded`).
   - `name`: A descriptive name for the patch.
   - `description`: A brief description of what the patch does.
   - `caution`: (Optional) A warning about the patch.

<details>
<summary><h3>For memory patches</h3></summary>

   - `patches`: Array containing objects with the following properties:
      - `start`: (Optional) The starting offset to search at, 0 by default (start of file).
      - `signature`: The byte signature to search for, with '??' representing any bytes.
      - `adjust`: (Optional) Adjustment to the found offset.
      - `data`: The data to write at the patch location.
      - `patchall`: (Optional) If true, apply the patch to all occurrences of the signature.

###### Example memory patch

```json
{
    "type": "memory",
    "name": "Mute Announcer",
    "description": "Mutes the announcer voice.",
    "patches": [
        {
            "start": 200000,
            "signature": "40 85 C0 0F 84 AE 03 00 00 83 F8 03 0F 84 A5 03",
            "adjust": 3,
            "data": "90 E9"
        },
        {
            "start": 2000000,
            "signature": "73 ?? 00 00 76 6F 69 63 65 00 00 00 ?? ?? ?? 10",
            "adjust": 4,
            "data": "62"
        }
    ]
}
```

</details>
<details>
<summary><h3>For union patches</h3></summary>

   - `start`: (Optional) The starting offset to search at, 0 by default (start of file).
   - `signature`: The byte signature to search for, with '??' representing any bytes.
   - `adjust`: (Optional) Adjustment to the found offset.
   - `patches`: Array containing one object per option with the following properties:
      - `name`: The name of the option.
      - `data`: The data to write at the patch location. If set to "default" it'll just add an option for the default value present in the DLL.

###### Example union patch

```json
{
    "type": "union",
    "name": "Game FPS Target",
    "description": "Forces the game to run at a specific FPS target.",
    "start": 9000000,
    "signature": "00 00 00 00 00 00 4E 40",
    "adjust": 6,
    "patches": [
        {
            "name": "60 FPS",
            "data": "default"
        },
        {
            "name": "120 FPS",
            "data": "5E"
        }
    ]
}
```

</details>
<details>
<summary><h3>For number patches</h3></summary>

   - `patch`: Object containing the following properties:
      - `start`: (Optional) The starting offset to search at, 0 by default (start of file).
      - `signature`: The byte signature to search for, with '??' representing any bytes.
      - `adjust`: Adjustment to the found offset.
      - `size`: The size (in bytes) of the number to patch.
      - `min`: The minimum value of the number.
      - `max`: The maximum value of the number.

###### Example number patch

```json
{
   "type": "number",
   "name": "Render Offset",
   "description": "Sets the render offset (Default: 2).",
   "patch": {
         "start": 100000,
         "signature": "00 00 00 B9 57 00 00 00 BA 24 00 00 00 BE 02 00",
         "adjust": 14,
         "size": 4,
         "min": 0,
         "max": 1000
   }
}
```

</details>
<details>
<summary><h3>For hardcoded patches</h3></summary>

**Hardcoded patches are a special case where the patch is not found by searching for a signature.**
Instead it's generated by a function named after the `id`, found inside the `find_sp2x_patches.py` script itself.

###### Example hardcoded patch

```json
{
   "type": "hardcoded",
   "name": "Hide premium guide banner",
   "description": "blpass_ef (rainbow outline on health gauge) is shown instead of pt_sousa_usr.",
   "id": "kfc_001"
}
```

</details>
